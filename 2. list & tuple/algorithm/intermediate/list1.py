# 알고리즘
# 알고리즘 개요
# 알고리즘이란? 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
# 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법, 어떠한 문제를 해결하기 위한 절차

# 알고리즘의 성능 분석
# 무엇이 좋은 알고리즘인가?
# 정확성 : 얼마나 정확하게 동작하는가? 
# 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가?
# 메모리 사용량: 얼마나 적은 메모리를 사용하는가?
# 단순성 : 얼마나 단순한가?
# 최적성 : 더 이상 개선할 여지 없이 최적화 되었는가?

# 많은 문제에서 알고리즘의 성능 분석 기준으로 알고리즘의 작업량을 비교
# ex) 1 ~ 100까지의 합을 구하는 문제
# 1) 1부터 100까지의 숫자를 하나 씩 더한다. => 덧셈 99번
# 2) 등차수열의 합 공식을 이용한다 => 덧셈 1번, 곱셈 1번, 나눗셈 1번

# 알고리즘의 작업량을 표현할 때, 시간복잡도라는 개념을 사용
# 실제 걸리는 시간을 측정
# 실행되는 명령문의 개수를 계산 <- 많이 사용됨

# 시간복잡도는 빅-오 표기법을 통해 나타냄
# 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
# 계수는 생략하여 표시
# ex) O(2n+1) = O(2n) = O(n)
# ex) O(4) = O(1)



### List ###
# 파이썬
# 실행시마다 소스를 기계어로 번역하는 인터프리터 언어
# 객체 지향 언어
# 하드웨어 성능이 좋지 않던 시기에는 프로그램 실행 속도에 관심, 그러나 하드웨어의 성능 개선으로 실행 속도의 차이가 크지 않음
# 파이썬의 모든 자료는 객체
# 변수에 값을 초기화 시 변수가 메모리에 생성됨

## Exhaustive Search ##
# 완전 검색이란?
# 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

# ex) Baby-gin Game
# 0 ~ 9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 
# 3장의 카드가 연속적인 번호를 갖는 경우 run, 동일한 변호를 갖는 경우 triplete이라고 함
# 6장의 카드가 run과 triplete로만 구성된 경우를 Baby-gin이라고 부름

# Baby-gin 여부 찾기
# 고려할 수 있는 모든 경우의 수 생성하기
# 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)
# 앞의 3자리와 뒤의 3자리를 잘라, run과 triplete 여부를 테스트하고 Baby-gin을 판단함

# 순열 : 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
# nPr로 표현, n * (n-1) * ... * (n-r+1)
# nPn의 경우, n!이라고 표기하며, Factorial이라고 부름

# {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
for i1 in range(1, 4) :
    for i2 in range(1, 4) :
        if i2 != i1 :
            for i3 in range(1, 4) :
                if i3 != i1 and i3 != i2 :
                    print(i1, i2, i3)



## Greedy Algorithm ##
# 탐욕 알고리즘아란?
# 최적 해를 구하는데 사용되는 근시안적인 방법
# 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달함
# 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 최종적인 해답이 최적이라는 보장은 없음

# 탐욕 알고리즘의 수행 과정
# 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합에 추가함
# 실행 가능성 검사 : 새로운 부분 해 집합이 실행 가능한지를 확인, 곧 문제의 제약 조건을 위반하지 않는지를 검사함
# 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지를 확인, 아직 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작함

# ex) 거스름돈 줄이기
# 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?
# 해 선택 : 가장 단위가 큰 동전을 골라 거스름돈에 추가함
# 실행 가능성 검사 : 거스름돈이 손님에게 내드려야 할 액수를 초과하는지를 확인, 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고, 
# 해선택으로 돌아가 현재보다 한 단계 작은 단위의 동전을 추가함
# 해 검사 : 거스름이 손님에게 내드려야 하는 액수와 일치하는지 확인, 액수가 모자라면 해 선택으로 돌아가서 거스름돈에 추가할 동전을 고름

# ex) Baby-gin Game
# 6개의 숫자를 이용하여 Counts 리스트에 표시
# 444345라면, Counts = [0, 0, 1, 4, 1, 0, 0, 0, 0, 0]
# Counts 리스트의 각 원소를 체크하여 run과 triplete 및 Baby-gin 여부를 판단함
# run 여부를 체크하면, Counts = [0, 0, 0, 3, 0, 0, 0, 0, 0, 0]
# triplete 여부를 체크하면, Counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 
# 조사에 사용한 데이터는 삭제함
# 남은 데이터를 다시 run과 triplete 중에 가능한지를 조사함

num = 456789
Counts = [0] * 12
for i in range(6) :
    Counts[num % 10] += 1
    num //= 10

i = 0
triplete, run = 0, 0
while i < 10 :
    if Counts[i] >= 3 :
        Counts[i] -= 3 
        triplete += 1
        continue
    if Counts[i] >= 1 and Counts[i+1] >= 1 and Counts[i+2] >= 1 :
        Counts[i] -= 1
        Counts[i+1] -= 1
        Counts[i+2] -= 1
        run += 1
        continue
    i += 1
if triplete + run == 2 :
    print('Baby-gin')


## Sort ##
# 정렬이란?
# 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값 혹은 그 반대의 순ㅅ더대로 재배열하는 것
# 키란 자료를 정렬하는 기준이 되는 특정 값
# ex) 서류 번호대로 정렬하기, 카드 번호대로 정렬하기 => 서류 번호, 카드 번호가 키 값

# 대표적인 정렬 방식의 종류
# 버블 정렬
# 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
# 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
# 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리로 정렬됨
# 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양 같아서 버블 정렬이라고 함
# 시간 복잡도 = O(n**2)

# ex) {55, 7, 78, 12, 42}를 버블 정렬하는 과정
# 첫 번째 단계
# {55, 7, 78, 12, 42}에서 55와 7을 비교, {7, 55, 78, 12, 42}로 변환
# {7, 55, 78, 12, 42}에서 55와 78을 비교, {7, 55, 78, 12, 42} 유지
# {7, 55, 78, 12, 42}에서 78과 12를 비교, {7, 55, 12, 78, 42}로 변환
# {7, 55, 12, 78, 42}에서 78과 42를 비교, {7, 55, 12, 42, 78}로 변환 / 맨 오른쪽 숫자는 78로 확정

# 두 번째 단계
# {7, 55, 12, 42, 78}에서 7과 55를 비교, {7, 55, 12, 42, 78} 유지
# {7, 55, 12, 42, 78}에서 55와 12를 비교, {7, 12, 55, 42, 78}로 변환
# {7, 12, 55, 42, 78}에서 55와 42를 비교, {7, 12, 42, 55, 78}로 변환 / 맨 오른쪽에서 두 번째 숫자는 55로 확정

# 세 번째 던계
# {7, 12, 42, 55, 78}에서 7과 12를 비교, {7, 12, 42, 55, 78} 유지
# {7, 12, 42, 55, 78}에서 12와 42를 비교, {7, 12, 42, 55, 78} 유지 / 맨 오른쪽에서 세 번째 숫자는 42로 확정

# 네 번째 단계
# {7, 12, 42, 55, 78}에서 7과 12를 비교, {7, 12, 42, 55, 78} 유지 / 맨 오른쪽에서 네 번째 숫자는 12로 확정

def BubleSort(a) :
    for i in range(len(a)-1, 0, -1) :
        for j in range(0, i) :
            if a[j] > a[j+1] :
                a[j], a[j+1] = a[j+1], a[j]

a = [7, 55, 12, 42, 78]
BubleSort(a)
print(a)

# 카운팅 정렬
# 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있느지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
# 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
# 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
# 시간 복잡도 : O(n + k) : n은 리스트의 개수, k는 정수의 최대값

# ex) {0, 4, 1, 3, 1, 2, 4, 1}을 카운팅 정렬하는 과정
# data = [0, 4, 1, 3, 1, 2, 4, 1]
# counts = [1, 3, 1, 1, 2], count[0] = 0의 발생 횟수, 즉 1번 을 표시하고
# counts = [1, 4, 5, 6, 8], 각 항목이 위치할 순서를 결정하기 위해 갯수를 조정, 즉 0은 1번, 1은 3번 나오기에 마지막 1번의 자리 값은 4
# 이제 data의 마지막 자리부터 읽어오는데, 마지막 자리가 1이므로, counts에서 1의 값을 하나 빼서 counts = [1, 3, 5, 6, 8]으로 조정하고,
# new_data = [0, 0, 0, 1, 0, 0, 0, 0]로 만듬
# data의 마지막에서 두 번째 자리는 4이므로, counts에서 4의 값을 하나 빼서 counts = [1, 3, 5, 6, 7]으로 조정하고,
# new_data = [0, 0, 0, 1, 0, 0, 0, 4]로 만듬
# data의 마지막에서 세 번째 자리는 2이므로, counts에서 2의 값을 하나 빼서 counts = [1, 3, 4, 6, 7]으로 조정하고,
# new_data = [0, 0, 0, 1, 2, 0, 0, 4]로 만듬
# data의 마지막에서 네 번째 자리는 1이므로, counts에서 1의 값을 하나 빼서 counts = [1, 2, 4, 6, 7]으로 조정하고,
# new_data = [0, 0, 1, 1, 2, 0, 0, 4]로 만듬
# data의 마지막에서 다섯 번째 자리는 3이므로, counts에서 3의 값을 하나 빼서 counts = [1, 2, 4, 5, 7]으로 조정하고,
# new_data = [0, 0, 1, 1, 2, 3, 0, 4]로 만듬
# data의 마지막에서 여섯 번째 자리는 1이므로, counts에서 1의 값을 하나 빼서 counts = [1, 1, 4, 5, 7]으로 조정하고,
# new_data = [0, 1, 1, 1, 2, 3, 0, 4]로 만듬
# data의 마지막에서 일곱 번째 자리는 4이므로, counts에서 4의 값을 하나 빼서 counts = [1, 1, 4, 5, 6]으로 조정하고,
# new_data = [0, 1, 1, 1, 2, 3, 4, 4]로 만듬
# data의 마지막에서 일곱 번째 자리는 0이므로, counts에서 0의 값을 하나 빼서 counts = [0, 1, 4, 5, 6]으로 조정하고,
# new_data = [0, 1, 1, 1, 2, 3, 4, 4]로 만듬

def CountingSort(A, B, k) : # A는 입력된 리스트, B는 정렬된 리스트, k는 사용된 숫자
    C = [0] * k
    for i in range(0, len(B)) :
        C[A[i]] += 1
    
    for i in range(1, len(C)) :
        C[i] += C[i-1]
    
    for i in range(len(B)-1, -1, -1) :
        B[C[A[i]]-1] = A[i]
        C[A[i]] -= 1

A = [0, 4, 1, 3, 1, 2, 4, 1]
B = [0]*len(A)
CountingSort(A, B, 5)
print(B)







